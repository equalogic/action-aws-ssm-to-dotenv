import '../../../../../../@smithy/types/dist-es/auth/auth.js';
import '../../../../../../@smithy/types/dist-es/auth/HttpApiKeyAuth.js';
import '../../../../../../@smithy/types/dist-es/endpoint.js';
import '../../../../../../@smithy/types/dist-es/extensions/checksum.js';
import '../../../../../../@smithy/types/dist-es/http.js';
import '../../../../../../@smithy/types/dist-es/profile.js';
import '../../../../../../@smithy/types/dist-es/transfer.js';
import { getValueFromTextNode } from '../../../../../../@smithy/smithy-client/dist-es/get-value-from-text-node.js';
import XMLParser from '../../../../../../fast-xml-parser/src/xmlparser/XMLParser.js';
import { collectBodyString } from '../common.js';

const parseXmlBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        const parser = new XMLParser({
            attributeNamePrefix: "",
            htmlEntities: true,
            ignoreAttributes: false,
            ignoreDeclaration: true,
            parseTagValue: false,
            trimValues: false,
            tagValueProcessor: (_, val) => (val.trim() === "" && val.includes("\n") ? "" : undefined),
        });
        parser.addEntity("#xD", "\r");
        parser.addEntity("#10", "\n");
        let parsedObj;
        try {
            parsedObj = parser.parse(encoded, true);
        }
        catch (e) {
            if (e && typeof e === "object") {
                Object.defineProperty(e, "$responseBodyText", {
                    value: encoded,
                });
            }
            throw e;
        }
        const textNodeName = "#text";
        const key = Object.keys(parsedObj)[0];
        const parsedObjToReturn = parsedObj[key];
        if (parsedObjToReturn[textNodeName]) {
            parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
            delete parsedObjToReturn[textNodeName];
        }
        return getValueFromTextNode(parsedObjToReturn);
    }
    return {};
});
const parseXmlErrorBody = async (errorBody, context) => {
    const value = await parseXmlBody(errorBody, context);
    if (value.Error) {
        value.Error.message = value.Error.message ?? value.Error.Message;
    }
    return value;
};

export { parseXmlBody, parseXmlErrorBody };
//# sourceMappingURL=parseXmlBody.js.map
